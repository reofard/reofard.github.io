---
title: "PIBT: 우선순위 기반 경로탐색"
excerpt: "Robot"

categories:
  - Path_Finding

tags:
  - [MAPF, Path Finding, Multi-Robot]

toc: true
toc_sticky: true
layout: post
use_math: true
 
date: 2025-04-12
last_modified_at: 2025-04-12
---

# **[Priority inheritance with backtracking for iterative multi-agent path finding]()**
---
이번에 소개할 알고리즘 Priority inheritance with backtracking for iterative multi-agent path finding(이하 PIBT)에서는 기존에 소개되었던 CBS계열 알고리즘과 다르게 **여러 에이전트의 인접한 움직임에 초점을 맞추어 단기적인 솔루션**을 만들어내는 방법이다. 이때 PIBT를 통해 얻어진 단기적인 솔루션을 반복적으로 수행하면 유한시간내에 모든 agent들이 도착할 수 있다는것을 보장할 수 있다.

이번 논문을 읽으면서 들었던 생각은 각 로봇은 process, thread이고, 로봇이 움직일 수 있는 맵들은 공유자원이라고 가정하여, 운영체제에서 각 프로세스간의 공유자원 데드락 문제를 해결하는 알고리즘과 비슷하다는 생각이 들었다. 과연 어떤 방식으로 계산하고 동작하길래, 단기솔루션만으로 데드락에 빠지지 않고, 항상 모든 로봇이 목적지에 도달 할 수 있다는 보장을 할 수 있을까? 한번 논문을 정리하고 알아보겠다.

<br>

# **PIBT**
---
PIBT간단 설명

## **Priority Based Planning**

우선 PIBT는 MAPF문제를 해결하기위해 반복적으로 one-timestep에서 각 로봇이 어떻게 움직여야 할지 계산한다. 이때 각 에이전트간의 우선순위를 지정하고, 우선순위가 높은 에이전트부터 다음 timestep에서 도달할 경로를 이웃 노드를 선택하고, 그런 다음 에이전트는 우선순위가 높은 에이전트가 요청한 노드를 피하면서 우선순위가 낮은 순서대로 다음 위치를 순차적으로 결정한다.

![Stuck Agent](/assets/img/StuckAgent.png)

하지만 이러한 우선순위 기반 경로탐색의 경우 위의 그림과 같이 우선순위가 높은 순서대로 에이전트가 $a_3, a_2, a_1$이 있다고 해보자. 이 상황에서 $a_1$은 자신보다 우선순위가 높은 $a_1, a_2$에 의해 현재 위치와 다음 timestep에서 갈 수 있는 모든 위치가 모두 선점되어 **stuck agent**가 된다. 결론적으로 위 그림의 예시와 같이 stuck agent는 다른 에이전트와의 충돌 없이는 어디에도 갈 수 없으므로 이러한 상황은 일종의 교착 상태로 간주할 수 있다.

<br>

## **Priority Inheritance**

앞선 우선순위 기반의 경로탐색에서 stuck agent가 발생한 이유를 **우선순위의 역전 현상**으로 볼 수 있다. 이는 우선순위가 높은 $a_3$이 주장하는 자원을 보유한 $a_1$이 중간 우선순위를 가진 $a_2$가 보유한 자원을 얻지 못한다는 의미이다. 이러한 우선순위 역전문제를 처리하는 고전적인 방법은 우선순위 상속을 이용하는 것이다. 우선순위 상속은 우선순위가 높은 에이전트가 우선순위가 낮은 에이전트가 소유한 자원을 필요로 할 때, 자원을 요청한 에이전트의 우선순위를 자원을 소유한 에이전트에 상속하여 빠르게 일시적으로 우선순위 레벨을 조정하는 방법이다.

![Priority Inheritance](/assets/img/PriorityInheritance.png)

위 그림은 그 이유는 우선순위가 낮은 $a_1$이 보유한 자원을 주장하는 $a_3$의 우선순위를 일시적으로 상속을 받기 때문에 일시적으로 $a_1$의 우선순위가 $a_2$보다 높아져 결과적으로 오른쪽 그림과 같이 움직이게 되어 교착을 회피하여 모든 에이전트가 움직일 수 있게 된다.

<br>

## **Backtracking**

우선순위 상속으로도 완벽하게 해결할 수 없다. 아래 그림과 같이 복잡한 상황에서의 우선순위 상속에 대해 간단하게 예를 들어보자. 먼저 $a_7$은 우선순위가 최상위, $a_3$는 최하위의 우선순위를 갖는다고 생각해보자. 아래 그림은 우선순위가 연속적으로 상속되어 $a_7 \rightarrow a_6 \rightarrow a_5 \rightarrow a_4 \rightarrow a_3$ 순서로 상속됨을 의미한다. 이때 $a_3$는 같은 우선순위를 상속한 $a_6$, $a_4$에 의해 갈 수 있는 모든 공간이 점유되어있는 상태이고, 이미 해당 에이전트들은 우선순위를 상속받았기 때문에 추가로 상속할 수 없다. 그렇기 때문에 $a_3$는 연속적인 우선순위 상속에 의해 움직일 수 없는 상태가 된다고 볼 수 있다.

![Complex Priority Inheritance](/assets/img/ComplexPriorityInheritance.png)

이런 문제를 해결할 수 있는 방법은 Backtracking 알고리즘을 사용하여 cycle을 발생시키지 않는 우선순위 순서를 찾아내는 것이다. 우선순위 상속을 실행하는 모든 에이전트는 상속 가능 여부(cycle을 포함하지 않는 상속이 가능한지) 결과를 재귀적으로 판단한다. 만약 가능하다면 해당 노드로 이동을 시키고, 그렇지 않으면 다른 노드에 대해 상속가능 여부를 판단해야 한다. 즉 재귀적으로 해당 노드로 이동이 가능한지 여부를 확인하는 것이다. 자세한 예시를 들어 다음 문단에서 설명해보겠다.

<br>

# **후기**
---
이번 논문은 계산 방법도 CBS보다 훨씬 간단하고, 기존의 Conflict based Search처럼 완벽하게 전체경로를 작성하지 않고 PIBT나 RHCR같이 현재 상황을 반영하여 주어진 경로를 일부만 수정하는 형식이라, 실제 내가 진행하고있는 Brown-Feild에서의 멀티로봇 관제 개발에서도 사용하기 좋을 것 같다. 이번 포스트에서는 간단히 넘어간 Graph-based SES(GSES)에서 PIBT의 우선순위 상속개념을 살짝 빌려와서 계산하면 더 빠르고 간결하게 문제를 해결할 수 있을것 같은데, 이건 이번 회사에서 한번 개발해보려고 한다.